[GA PARAMETERS]
population_size = 50
generations = 500
genotypic_length = 24
mutation_probability = 0.0021
crossover_probability = 0.7
elitism_fraction = 0.1
desired_freq = 10000
; Options:	SINGLE_ELITE (top individual is an elite)
;			FRAC_ELITE (uses the elitism_fraction to determine number of elites)
;			CLASSIC_TOURN (runs a classic tournament)
;			FIT_PROP_SEL (fitness-proportional selection)
;			RANK_PROP_SEL (rank-proportional selection)
;			MAP_ELITES (MAP-elites inspired method, maps waveforms to a grid and copies/mutates the best in each cell for the next generation)
selection = FIT_PROP_SEL
; Options:	PULSE (until pulses detected)
;			VARIANCE (until variance crosses certain threshold)
;			NO (no randomization, just begin evolution immediately)
randomize_until = PULSE
variance_threshold = 4
; Options:	CLONE_SEED (clones the seed hardware to every individual in the population)
;			CLONE_SEED_MUTATE (clones the seed hardware to every indvidual, and then mutates each of them)
;			RANDOM (completely randomizes the [modifiable] bitstream of all individuals)
;			EXISTING_POPULATION (uses the existing population as-is)
init_mode = CLONE_SEED
pulse_func = True
; Options: 	FULLY_INTRINSIC (compiles bitstreams to circuits and runs on the FPGA)
;				- Used to actually run on the hardware
;			SIM_HARDWARE (compiles the bitstreams and arbitrarily evaluates their fitness all on the computer)
;				- Used for testing the evolutionary functions and well as how crossover/mutation performs on the files
;			FULLY_SIM (generates sine waves that can be treated like variance measure outputs)
;				- Used for testing the evolutionary method and variance fitness functions, not ensuring mutation and crossover are functional on the files
; We recommend not using any of the modes other than FULLY_INTRINSIC unless you are modifying code and testing it
simulation_mode = FULLY_INTRINSIC
; Options:	HAMMING_DIST (uses the average Hamming distance as the diversity measure)
;			UNIQUE (uses the count of unique individuals as the diversity measure)
diversity_measure = HAMMING_DIST
; Options:	VARIANCE (uses the variance fitness function)
;			PULSE_COUNT (uses the pulse count fitness function)
;			COMBINED (uses variance and closeness to trigger voltage)
; This is independent of the data measured from the MCU, and only defines how that data should be handled
fitness_func = PULSE_COUNT
; Options:	AVG (uses the average of all samples)
;			OUTLIERS (takes the average of all samples after removing those that are more than 2 standard deviations from the mean)
;			MEDIAN (uses the median of all samples)
;			PERCENTAGE (removes the top and bottom 10% of samples and returns the mean)
sampling_method = MEDIAN
; Options:	ADC (takes 500 voltage samples over 5ms)
;			PULSE_COUNT (counts the number of pulses that cross a threshold over 1s)
;			PULSE_WIDTH
measurement_type = PULSE_COUNT
num_samples = 2
random_injection = 0.0

[FITNESS FUNC PARAMETERS]
; Options:  ADD (adds the two fitness measures together with weighting)
;			MULT (multiplies the two fitness measures together)
fitness_mode = ADD
pulse_weight = 10
var_weight = 1

[LOGGING PARAMETERS]
asc_dir = ...../workspace/experiment_asc
bin_dir = ...../workspace/experiment_bin
data_dir = ...../workspace/experiment_data
analysis = ...../workspace/analysis
monitor_file = ...../data/monitor
; TODO: update makefile?
best_file = ...../workspace/best.asc
src_population_dir = ...../workspace/source_population
launch_monitor = True
datetime_format = %%m/%%d/%%Y - %%H:%%M:%%S
; Log Level varies from 1-4
; Higher log level = more detailed logs
log_level = 2

[SYSTEM PARAMETERS]
fpga = i:0x0403:0x6010:0
usb_path = /dev/ttyUSB0

[HARDWARE PARAMETERS]
routing = MOORE
mcu_read_timeout = 1.1
serial_baud = 115200
accessed_columns = 14,15,24,25,40,41
protected_columns = 0,1,2,3,4,5,6,7,8,9,10,11,12,13,16,17,18,19,
	20,21,22,23,26,27,28,29,30,31,32,33,34,35,36,
	37,38,39,42,43,44,45,46,47,48,49,50,51,52,53

