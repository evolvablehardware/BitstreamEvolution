"""
Circuit.py
----------
This file holds a class thet contains information needed to 

"""
from __future__ import annotations
from subprocess import run
from time import time, sleep
from shutil import copyfile
from mmap import mmap
from io import SEEK_CUR
from statistics import stdev
import math
import numpy as np
import re

import typing

# Ugly way to avoid circular imports
# Will only import these at type-checking time, not at runtime
if typing.TYPE_CHECKING:
    from Microcontroller import Microcontroller
    from Logger import Logger
    from Config import Config

# TODO Integrate globals in a more elegant manner.
RUN_CMD = "iceprog"
COMPILE_CMD = "icepack"

def is_pulse_func(config):
    """
    Used in multiple places, will be removed soon.

    .. todo::
        unite the is_pulse_func() across files!

    Parameters
    ----------
    config : Config
        Configuration Class to interact with config

    Returns
    -------
    bool
        True if it is any type of oscilator (uses count pulses), False otherwise.
    """
    return (config.get_fitness_func() == 'PULSE_COUNT' or config.get_fitness_func() == 'TOLERANT_PULSE_COUNT' 
            or config.get_fitness_func() == 'SENSITIVE_PULSE_COUNT' or config.get_fitness_func() == 'PULSE_CONSISTENCY')

class Circuit:
    """
    Represents a manifestation of a particular configuration
    on an FPGA and all its associated information. It tracks the
    location of the various files associated with the FPGA
    configurations as well as GA information associated with the
    configuration. This class also defines methods to run, modify,
    and analyze FPGA configurations.
    """

    def __repr__(self):
        """
        Returns the string representation of this Circuit, used in
        functions such as 'print'.

        Returns
        -------
        str
            A string representation of the Circuit. (the file name)
        """
        return self.__filename

    def __init__(self, index: int, filename: str, template, mcu: Microcontroller, 
            logger: Logger, config: Config, rand, sine_funcs):
        """
        Creates a circuit object.

        Parameters
        ----------
        index : int
            The unique (within this experiment) 0-based index of the circuit.
        filename : str
            The path of the file we will use to store this Circuit.
        template : str
            A file path of the Circuit, which will be cloned into this Circuit's hardware file.
        mcu : Microcontroller
            The Microcontroller object that we will use to interface with the FPGA and measure its fitness
        logger : Logger
            The logger object the circuit will write logs to
        config : Config
            This is an object that informs you of the configuration options in the configuration file.
        rand : numpy.random
            Used to generate random values.
        sine_funcs : list[Callable]
            These are a list of functions which return sin functions.
            Currently these are generated by CircuitPopulation.__generate_sine_funcs()
        """
        self.__index = index
        self.__filename = filename
        self.__microcontroller = mcu
        self.__config = config
        self.__logger = logger
        self.__rand = rand
        self.__fitness = 0
        self.__mean_voltage = 0 #needed for combined fitness func
        self.__pulses = 0 # Used to get pulses counted outside of circuit
        self.__data = [] # Used when taking multiple samples in a single generation. Stores the fitnesses

        # SECTION Build the relevant paths
        asc_dir = config.get_asc_directory()
        bin_dir = config.get_bin_directory()
        data_dir = config.get_data_directory()
        self.__hardware_filepath = asc_dir.joinpath(filename + ".asc")
        self.__bitstream_filepath = bin_dir.joinpath(filename + ".bin")

        # NOTE Using log files instead of a data buffer in the event of premature termination
        self.__data_filepath = data_dir.joinpath(filename + ".log")

        # SECTION Intialize the hardware file
        # If template is falsy, won't copy the file
        if template:
            copyfile(template, self.__hardware_filepath)

        # Since the hardware file is written to and read from a lot, we
        # mmap it to improve preformance.
        hardware_file = open(self.__hardware_filepath, "r+")
        self.__hardware_file = mmap(hardware_file.fileno(), 0)
        hardware_file.close()
        
        # Used for the sine simulation mode; up to 100 sine waves
        self.__src_sine_funcs = sine_funcs
        self.__simulation_bitstream = [0] * 100

        # Values for MAP elites
        self.__low_val = 0
        self.__high_val = 0

    @staticmethod
    def get_file_attribute_st(mmapped_file, attribute):
        '''
        Returns the value of the stored attribute from the hardware file.
        Circuits are capable of storing string name-value pairs in their hardware file, for purposes such as
        tracking most recently-evaluated fitness of a Circuit
        Static version of get_file_attribute that requires the memory-mapped file to be provided

        Parameters
        ----------
        mmapped_file : mmap
            The memory-mapped hardware file of the circuit
        attribute : str
            Attribute name to lookup

        Returns
        -------
        str
            File attribute value
        '''
        index = mmapped_file.find(b".comment FILE_ATTRIBUTES")
        if index < 0:
            return '0'
        else:
            newline_index = mmapped_file.find(b'\n', index)
            searchable_area = mmapped_file[index:newline_index]
            attr_index = searchable_area.find(bytes(attribute + '={', 'utf-8'))
            if attr_index < 0: # Value doesn't exist yet
                return '0'
            attr_index = attr_index + len(attribute + "={")
            end_index = searchable_area.find(b'}', attr_index)
            value_bytes = searchable_area[attr_index:end_index]
            return str(value_bytes, 'utf-8')

    @staticmethod
    def set_file_attribute_st(hardware_file, attribute, value):
        '''
        Sets a Circuit's file attribute to the specified value
        Circuits are capable of storing string name-value pairs in their hardware file, for purposes such as
        tracking most recently-evaluated fitness of a Circuit
        Static version of set_file_attribute that requires the memory-mapped file to be provided

        Parameters
        ----------
        hardware_file : mmap
            The memory-mapped hardware file of the Circuit
        attribute : str
            The name of the attribute to modify
        value : str
            The value to assign to the attribute
        '''
        # Check if the comment exists
        #hardware_file = open(file_path, "r+")
        mmapped_file = mmap(hardware_file.fileno(), 0)
        index = mmapped_file.find(b".comment FILE_ATTRIBUTES")
        if index < 0:
            # Create the comment
            comment_line = ".comment FILE_ATTRIBUTES " + attribute + "={" + value + "}\n"
            # This requires re-mapping the self.__hardware_file
            #hardware_file = open(file_path, "r+")
            content = hardware_file.read()
            hardware_file.seek(0, 0)
            hardware_file.write(comment_line + content)
        else:
            # Check if the attribute exists
            end_index = mmapped_file.find(b'\n', index)
            line = str(mmapped_file[index:end_index], 'utf-8')
            attr_index = line.find(attribute + "={")
            lines = hardware_file.readlines()
            line_index = 0 # Index of the line that contains the attribute comment
            for l in lines:
                if l.find(".comment FILE_ATTRIBUTES") >= 0:
                    break
                line_index = line_index + 1

            if attr_index < 0:
                # Attribute doesn't exist yet
                line = line + " " + attribute + "={" + value + "}\n"
            else:
                attr_end_index = line.find('}', attr_index) + 2
                before_attr = line[:attr_index]
                after_attr = line[attr_end_index:]
                line = before_attr + attribute + "={" + value + "} " + after_attr + '\n'
            lines[line_index] = line
            hardware_file.truncate(0)
            hardware_file.seek(0)
            hardware_file.writelines(lines)

    def get_file_attribute(self, attribute):
        '''
        Returns the value of the stored attribute for this Circuit
        Circuits are capable of storing string name-value pairs in their hardware file, for purposes such as
        tracking most recently-evaluated fitness of a Circuit

        Parameters
        ----------
        attrbute : str
            The name of the attribute of this circuit you want

        Returns
        -------
        str
            The value of the attribute
        '''
        return Circuit.get_file_attribute_st(self.__hardware_file, attribute)
    
    def set_file_attribute(self, attribute, value):
        '''
        Sets this Circuit's file attribute to the specified value
        Circuits are capable of storing string name-value pairs in their hardware file, for purposes such as
        tracking most recently-evaluated fitness of a Circuit

        Parameters
        ----------
        attribute : str
            The name of the attribute to modify
        value : str
            The value to assign to the attribute
        '''
        hardware_file = open(self.__hardware_filepath, "r+")
        Circuit.set_file_attribute_st(hardware_file, attribute, value)
        # Re-map our hardware file
        self.__hardware_file = mmap(hardware_file.fileno(), 0)
        hardware_file.close()

    def randomize_bits(self):
        """
        Completely randomize all of the modifiable bits of the circuit.
        """
        if self.__config.get_simulation_mode() == "FULLY_SIM":
            self.__mutate_simulation(True)
        else:
            self.__mutate_actual(True)

    def __compile(self):
        """
        Compile circuit ASC file to a BIN file for hardware upload.
        """
        self.__log_event(2, "Compiling", self, "with icepack...")

        # Ensure the file backing the mmap is up to date with the latest
        # changes to the mmap.
        self.write_hardware_changes()

        compile_command = [
            COMPILE_CMD,
            self.__hardware_filepath,
            self.__bitstream_filepath
        ]
        run(compile_command);

        self.__log_event(2, "Finished compiling", self)

    def get_sim_bitstream(self):
        """
        Returns the simulation bitstream array

        Returns
        -------
        list[int]
            The bitstream of this circuit
        """
        return self.__simulation_bitstream

    def get_hardware_file_path(self):
        """
        Returns the hardware file path

        Returns
        -------
        Path
            returns the path of the circuit
        """
        return self.__hardware_filepath

    def calculate_fitness_from_data(self):
        """
        Calculates the fitness of this circuit from stored samples in self.__data
        If performing multi-sample/pass pulse function, then takes the product of fitnesses.
        If performing pulse consistency, then calculates the pulse consistency fitness using the sample data.

        .. todo::
            There was the following TODO statement at the bottom of the code:
            TODO Evaluate based on a fitness function defined in the config file
            while still utilizing the existing or newly added evaluate functions in this class::
            
                def evaluate(self):
                    return
             
        
        Returns
        -------
        float
            The fitness found from analyzing data
        """
        # Flatten the data list
        data = [item for sublist in self.__data for item in sublist]
        if self.__config.get_fitness_func() == "PULSE_CONSISTENCY":
            # Get all values not between 1,000 and 100,000
            invalid_data = [point for point in data if point < 1_000 or point > 100_000]
            # If there are any "bad" pulse counts, we just say our fitness is 0
            # Even one would break consistency anyway, we want to force things between the desired range
            if len(invalid_data) > 0:
                fit = 0
                self.__log_event(2, "Data had invalid values, fitness is 0")
            else:
                std = stdev(data)
                self.__mean_freq = sum(data) / len(data)
                fit = 1_000 / (std + 1)
                self.__log_event(2, "Consistency std", std, "data", data, "fitness", fit)
        else:
            # Pulse fitness will be > 1 if there were more than 0 pulses detected
            # Therefore to combine pulse fitnesses, subtract 1 from each, multiply them together,
            # then add 1 to the resultant
            any_pulses = False
            product = 1
            for value in data:
                if value > 1:
                    value = value - 1
                    any_pulses = True
                product = product * value
            fit = product
            if any_pulses:
                fit = fit + 1
        self.__fitness = fit
        self.__update_all_live_data()
        self.__data = []
        return fit

    # TODO Evaluate based on a fitness function defined in the config file
    # while still utilizing the existing or newly added evaluate functions in this class
    # def evaluate(self):
    #     return 
    
    def evaluate_sim(self, is_combined):
        """
        Just evaluate the simulation bitstream (use sine function combinations, with variance formula)
        
        Parameters
        ----------
        is_combined : bool
            True if evaluating combined fitness, False if evaluating varience fitness

        Returns
        -------
        float
            True if it is any type of oscilator (uses count pulses), False otherwise.
        """
        
        # Need to sum up the waveforms of every 1 that appears in our bitstream
        sine_funcs = []
        for pos in range(len(self.__simulation_bitstream)):
            if self.__simulation_bitstream[pos] == 1:
                # Need to calculate sine function for this position
                sine_funcs.append(self.__src_sine_funcs[pos])

        # Force them to have at least 10 sine functions turned on
        if len(sine_funcs) <= 10:
            self.__fitness = 0
            return 0

        # Ok now we need to generate our waveform
        num_samples = 500
        waveform = []
        for i in range(num_samples):
            sum = 0
            for func in sine_funcs:
                sum = sum + func(i)
            # Taking the average keeps it within the drawable range
            waveform.append(sum / len(sine_funcs))
        
        if is_combined:
            fitness = self.__measure_combined_fitness(waveform)
        else:
            fitness = self.__measure_variance_fitness(waveform)

        self.__update_all_live_data()
        return fitness

    def evaluate_sim_hardware(self):
        """
        Sum up all the bytes in the compiled binary file

        Returns
        -------
        int
            The fitness of the sim hardware. (sum of all bytes in compiled binary file)
        """
        
        self.__compile()
        
        self.__fitness = 0
        with open(self.__bitstream_filepath, "rb") as f:
            byte = f.read(1)
            while byte != b"":
                self.__fitness = self.__fitness + int.from_bytes(byte, "big")
                byte = f.read(1)
        
        self.__log_event(3, "Fitness: ", self.__fitness)

        self.__update_all_live_data()

        return self.__fitness

    def evaluate_variance(self, record_data = False):
        """
        Upload and run this Circuit on the FPGA and analyze its
        performance.

        Parameters
        ----------
        record_data : bool
            Whether or not we want to save the data to this Circuit's sample data collection.
            Used when performing multiple samples/passes.
            Defaults to False.
            If set to False, all live data is updated upon the running of this function

        Returns
        -------
        float
            The resulting fitness of the fitness calculation.
        """
        start = time()

        self.__run()
        self.__microcontroller.measure_signal(self)

        elapsed = time() - start
        self.__log_event(1,
            "TIME TAKEN RUNNING AND LOGGING ---------------------- ",
            elapsed
        )

        waveform = self.__read_variance_data()
        fitness = self.__measure_variance_fitness(waveform)

        if record_data:
            # We will update all live data when all samples have been taken
            self.__data.append(fitness)
        else:
            self.__update_all_live_data()

        return fitness

    def evaluate_tonedisc(self, record_data = False):
        """
        Upload and run this Circuit on the FPGA and analyze its
        performance.

        Parameters
        ----------
        record_data : bool
            Whether or not we want to save the data to this Circuit's sample data collection.
            Used when performing multiple samples/passes.
            Defaults to False.
            If set to False, all live data is updated upon the running of this function

        Returns
        -------
        float
            The resulting fitness of the fitness calculation.
        """
        start = time()

        self.__run()
        self.__microcontroller.measure_signal_td(self)

        elapsed = time() - start
        self.__log_event(1,
            "TIME TAKEN RUNNING AND LOGGING ---------------------- ",
            elapsed
        )

        waveform = self.__read_variance_data_td()[0]
        state = self.__read_variance_data_td()[1]
        fitness = self.__measure_tonedisc_fitness(waveform, state)

        if record_data:
            # We will update all live data when all samples have been taken
            self.__data.append(fitness)
        else:
            self.__update_all_live_data()

        return fitness

    def evaluate_pulse_count(self, record_data = False):
        """
        Upload and run this circuit and count the number of pulses it
        generates.
        Returns the fitness of this circuit

        Parameters
        ----------
        record_data : bool
            Whether or not we want to save the data to this Circuit's sample data collection.
            Used when performing multiple samples/passes.
            Defaults to False.
            If set to False, all live data is updated upon the running of this function

        Returns
        -------
        float
            The Pulse Count fitness from this circuit.
        """
        start = time()
        self.__run()
        #self.__microcontroller.measure_pulses(self)
        self.__microcontroller.simple_measure_pulses(self, self.__config.get_num_samples())

        elapsed = time() - start
        self.__log_event(1,
            "TIME TAKEN RUNNING AND LOGGING ---------------------- ",
            elapsed
        )

        measure_result = self.__measure_pulse_fitness(record_data = record_data)

        if record_data:
            # We will update all live data when all samples have been taken
            self.__data.append(measure_result)
        else:
            self.__update_all_live_data()

        # This is either the fitness or the list of pulses counted
        return measure_result

    def evaluate_combined(self, record_data = False):
        """
        Upload and run this circuit and take a combined measure of fitness

        Parameters
        ----------
        record_data : bool
            True to record data locally, False to only update live data.

        Returns
        -------
        float
            Fitness of the combined fitness.
        """
        start = time()
        self.__run()
        self.__microcontroller.measure_signal(self)

        elapsed = time() - start
        self.__log_event(1,
            "TIME TAKEN RUNNING AND LOGGING ---------------------- ",
            elapsed
        )

        waveform = self.__read_variance_data()
        fitness = self.__measure_combined_fitness(waveform)
        
        if record_data:
            # We will update all live data when all samples have been taken
            self.__data.append(fitness)
        else:
            self.__update_all_live_data()

        return fitness

    def measure_mean_voltage(self):
        """
        Upload and run this circuit and take a mean voltage measure

        Returns
        -------
        float
            The mean voltage or the run.
        """
        start = time()
        self.__run()
        self.__microcontroller.measure_signal(self)

        elapsed = time() - start
        self.__log_event(1,
            "TIME TAKEN RUNNING AND LOGGING ---------------------- ",
            elapsed
        )

        waveform = self.__read_variance_data()
        return self.__measure_mean_voltage(waveform)

    def __run(self):
        """
        Compiles this Circuit, uploads it, and runs it on the FPGA
        """
        self.__compile()
        
        cmd_str = [
            RUN_CMD,
            self.__bitstream_filepath,
            "-d",
            self.__microcontroller.get_fpga()
        ]
        print(cmd_str)
        run(cmd_str)
        sleep(1)

        # if switching fpgas every sample, need to upload to the second fpga also
        if self.__config.get_transfer_sample():
            cmd_str = [
                RUN_CMD,
                self.__bitstream_filepath,
                "-d",
                self.__config.get_fpga2()
            ]
            print(cmd_str)
            run(cmd_str)
            sleep(1)

    def __read_variance_data(self):
        """
        Reads variance data from the Circuit data file, which contains readings from the Microcontroller

        Returns
        -------
        list[int]
            waveform
        """
        data_file = open(self.__data_filepath, "rb")
        data = data_file.readlines()
        total_samples = 500
        waveform = []
        for i in range(total_samples-1):
            try:
                x = int(data[i].strip().split(b": ", 1)[1])
                waveform.append(x)
            except:
                self.__log_error(1, "FAILED TO READ {} AT LINE {} -> ZEROIZING LINE".format(
                    self,
                    i
                ))
                waveform.append(0)

        self.__log_event(5, "Waveform: ", waveform) 
        return waveform

    def __read_variance_data_td(self):
        """
        Reads variance data from the Circuit data file, which contains readings from the Microcontroller

        Returns
        -------
        list[int]
            waveform
        """
        data_file = open(self.__data_filepath, "rb")
        data = data_file.readlines()
        total_samples = 500
        waveform = []
        state = []
        for i in range(total_samples-1):
            try:
                dataPoint = data[i].decode("utf-8")
                
                x = int(re.split(" ", dataPoint)[1])
                y = int(re.split(" ", dataPoint)[2])

                waveform.append(x)
                state.append(y)
            except:
                self.__log_error(1, "RIP FAILED TO READ {} AT LINE {} -> ZEROIZING LINE".format(
                    self,
                    i
                ))
                waveform.append(0)
                state.append(0)

        self.__log_event(5, "Waveform: ", waveform)
        self.__log_event(5, "State: ", state) 
        return [waveform, state]

    def get_waveform(self):
        """
        Returns the stored waveform from the most-recent run, as an array of strings.

        Returns
        -------
        list[str]
            waveform
        """

        wf = []
        for pt in self.__read_variance_data():
            wf.append(str(pt))
        return wf

    def get_waveform_td(self):
        """
        Returns the stored waveform from the most-recent run, as an array of strings.

        Returns
        -------
        list[str]
            waveform
        """

        wf = []
        for pt in self.__read_variance_data_td()[0]:
            wf.append(str(pt))
        return wf

    def get_state_td(self):
        """
        Returns the stored waveform from the most-recent run, as an array of strings.

        Returns
        -------
        list[str]
            waveform
        """

        wf = []
        for pt in self.__read_variance_data_td()[1]:
            wf.append(str(pt))
        return wf

    # NOTE Using log files instead of a data buffer in the event of premature termination
    def __measure_variance_fitness(self, waveform):
        """
        Measure the fitness of this circuit using the variance-maximization fitness
        function
        
        Parameters
        ----------
        waveform : list[int]
            Waveform of the run

        Returns
        -------
        float
            The fitness. (Variance Maximization Fitness)
        """

        variance_sum = 0
        total_samples = 500
        variances = []
        # Reset high/low vals to min/max respectively
        self.__low_val = 1024
        self.__high_val = 0
        for i in range(len(waveform)-1):
            # NOTE Signal Variance is calculated by summing the absolute difference of
            # sequential voltage samples from the microcontroller.
            # Capture the next point in the data file to a variable
            initial1 = waveform[i] #int(data[i].strip().split(b": ", 1)[1])
            # Capture the next point + 1 in the data file to a variable
            initial2 = waveform[i+1] #int(data[i + 1].strip().split(b": ", 1)[1])
            # Take the absolute difference of the two points and store to a variable
            variance = abs(initial2 - initial1)
            # Append the variance to the waveform list
            # Removed since we do this already
            #waveform.append(initial1)

            if initial1 < self.__low_val:
                self.__low_val = initial1
            if initial1 > self.__high_val:
                self.__high_val = initial1

            # Stability: if we want stable waves, we should want to differences between points to be
            # similar. i.e. we want to minimize the differences between these differences
            # Can do 1/[(std. deviation)+0.01] to find a fitness value for the stability
            # To do that we'll start by storing the variances to its own collection
            # NOTE: This encourages frequencies that match the sampling rate
            variances.append(variance)

            if initial1 != None and initial1 < 1000:
                variance_sum += variance

        with open("workspace/waveformlivedata.log", "w+") as waveLive:
            i = 1
            for points in waveform:
                waveLive.write(str(i) + ", " + str(points) + "\n")
                i += 1

        var_max_fitness = variance_sum / total_samples
        self.__fitness = var_max_fitness
        self.__mean_voltage = sum(waveform) / len(waveform) #used by combined fitness func

        return self.__fitness
    
    def __measure_tonedisc_fitness(self, waveform, state):
        """
        Measure the fitness of this circuit using the variance-maximization fitness
        function
        
        Parameters
        ----------
        waveform : list[int]
            Waveform of the run

        Returns
        -------
        float
            The fitness. (Variance Maximization Fitness)
        """

        difference_sum = 0
        waveform_sums = [0, 0]
        waveform_sum = 0
        total_samples = 500
        stateZeroCount = 0
        stateOneCount = 0
        # Reset high/low vals to min/max respectively
        self.__low_val = 1024
        self.__high_val = 0
        for i in range(len(waveform)):
            waveformPoint = waveform[i]
            waveform_sum += waveformPoint

            if waveformPoint < self.__low_val:
                self.__low_val = waveformPoint
            if waveformPoint > self.__high_val:
                self.__high_val = waveformPoint

            if waveformPoint != None and waveformPoint < 1000:
                if state[i] == 0:
                    stateZeroCount += 1
                    waveform_sums[0] += waveformPoint
                else:
                    stateOneCount += 1
                    waveform_sums[1] += waveformPoint

        with open("workspace/waveformlivedata.log", "w+") as waveLive:
            i = 1
            for points in waveform:
                waveLive.write(str(i) + ", " + str(points) + "\n")
                i += 1

        with open("workspace/statelivedata.log", "w+") as stateLive:
            i = 1
            for points in state:
                stateLive.write(str(i) + ", " + str(points) + "\n")
                i += 1

        if waveform_sum == 0:
            self.__fitness = 0
        else:
            stateZeroAve = (waveform_sums[0] / stateZeroCount)
            stateOneAve = (waveform_sums[1] / stateOneCount)
            self.__fitness = 0.00001 * abs(stateZeroAve - stateOneAve)
            self.__log_event(1,
            "State 0 Average = ",
            stateZeroAve, " --- State 0 Count = ", stateZeroCount, " ----- State 1 Average = ", stateOneAve)
        
        self.__mean_voltage = sum(waveform) / len(waveform) #used by combined fitness func

        return self.__fitness

    def __is_tolerant_pulse_count(self):
        """
        Checks if the config requests a tolerant pulse count.

        Returns
        -------
        bool
            True if Tolerant Pulse Count fitness function, otherwise false.
        """
        return self.__config.get_fitness_func() == 'TOLERANT_PULSE_COUNT'

    # NOTE Using log files instead of a data buffer in the event of premature termination
    def __measure_pulse_fitness(self, record_data = False):
        """
        Measures the fitness of this circuit using the pulse-count
        fitness function
        If record_data is true, then we will return the total pulses counted
        Otherwise, we will return the calculated fitness

        .. todo::
            Preexisting comment: ``TODO: Refactor``
        
        .. todo::
            Preexisting comments in this area suggest we use log files instead of data buffer in the event of a premature termination.

        Parameters
        ----------
        record_data : bool
            Default to False. Returns total pulses counted if True, otherwise calculated fitness is returned.

        Returns
        -------
        float
            The fitness value for pulse fitness.
        list[int]
            Total Pulse Counts (if record_data is true)
        """
        data_file = open(self.__data_filepath, "r")
        data = data_file.readlines()

        # Extract the integer value from the log file indicating the pulses counted from
        # the microcontroller. Pulses are currently measured by Rising or Falling edges
        # that cross the microcontrollers reference voltage (currently ~2.25 Volts) [TODO: verify]
        pulse_counts = []
        for i in range(len(data)):
            pulse_counts.append(int(data[i]))
        
        if record_data:
            return pulse_counts
        
        # Set pulse_count to whichever one is furthest away
        dist = 0
        for pc in pulse_counts:
            this_dist = abs(pc - self.__config.get_desired_frequency())
            if this_dist >= dist:
                dist = this_dist
                pulse_count = pc
        
        self.__log_event(3, "Pulses counted: {}".format(pulse_count))
        self.__pulses = pulse_count

        if len(pulse_counts) == 0:
            self.__log_event(2, "NULL DATA FILE. ZEROIZING")

        self.__fitness = self.__calc_pulse_fitness(pulse_count)
        
        return self.__fitness

    def __calc_pulse_fitness(self, pulses):
        """
        Returns the fitness, based on the config's fitness function, for the specified number of pulses

        Parameters
        ----------
        pulses : int
            The number of pulses counted.

        Returns
        -------
        float
            Fitness of the pulse count.
        """
        desired_freq = self.__config.get_desired_frequency()
        fitness = 0
        if self.__is_tolerant_pulse_count():
            # Build a normal-ish distribution function where the "mean" is desired_freq,
            # and the "standard deviation" is of our choosing (here we select 0.025*freq)
            deviation = 0.025 * desired_freq # 25 for 1,000 Hz, 250 for 10,000 Hz
            # No need to check for this because it's included in the function
            # Note: Fitness is still from 0-1
            fitness = math.exp(-0.5 * math.pow((pulses - desired_freq) / deviation, 2))
        else:
            if pulses == desired_freq:
                self.__log_event(1, "Unity achieved: {}".format(self))
                fitness = 1
            elif pulses == 0:
                fitness = 0
            else:
                fitness = 1.0 / abs(desired_freq - pulses)

        if pulses > 0:
            # Give fitness bonus for getting above 0 pulses
            fitness = fitness + 1
        return fitness

    def __measure_combined_fitness(self, waveform):
        """
        Calculates the circuit's fitness based on a combination of it's pulse count and variance

        Parameters
        ----------
        waveform : list[int]
            Waveform of the run. Each entry is a normalized voltage reading

        Returns
        -------
        float
            Fitness of the combined fitness function
        """

        # need to evaluate var fitness first since it calculates the mean voltage
        varFitness = self.__measure_variance_fitness(waveform)
        varWeight = self.__config.get_var_weight()

        # Using the different between average and threshhold voltage since pulse count is normally 0
        # pulseFitness = self.__measure_pulse_fitness()
        # Add 1 to it so that it is a whole number, and raising to a power will increase the value
        #pulseFitness = 1 / (abs(self.__mean_voltage - 341) + 1) + 1
        # Issue with old approach is graph was mostly a straight line with a spike at the target voltage
        # We've changed to a somewhat normal distribution-like function to provide better encouragement
        # Constants:
        # The 341 is the target threshold voltage
        # The 200 is used as a sort of "standard deviation"-esque variable. Raising it widens the graph
        pulseFitness = 10 * math.exp(-0.5 * math.pow((self.__mean_voltage - 341) / 200, 2))
        pulseWeight = self.__config.get_pulse_weight()

        self.__log_event(4, "Pulse Fitness: ", pulseFitness)
        self.__log_event(4, "Variance Fitness: ", varFitness)

        if self.__config.get_combined_mode() == "ADD":
            self.__fitness = (pulseWeight * pulseFitness) + (varWeight * varFitness)
        else: #MULT
            self.__fitness = pow(pulseFitness, pulseWeight) * pow(varFitness, varWeight)

        self.__log_event(3, "Combined Fitness: ", self.__fitness)
        
        return self.__fitness
 
    def __measure_mean_voltage(self, waveform):
        """
        Measures mean voltage. (Just calls __measure_variance_fitness())

        Parameters
        ----------
        waveform : list[int]
            Waveform from an evolution run

        Returns
        -------
        float
           mean voltage, a.k.a variance fitness
        """
        self.__measure_variance_fitness(waveform)
        return self.__mean_voltage

    def __update_all_live_data(self):
        '''
        Updates this circuit's entry in alllivedata.log (the circuit's fitness and source population)
        '''
        # Read in the file contents first
        lines = []
        with open("workspace/alllivedata.log", "r") as allLive:
            lines = allLive.readlines()

        # Modify the content internally
        index = self.__index - 1
        if len(lines) <= index:
            for i in range(index - len(lines) + 1):
                lines.append("\n")

        # Shows pulse count in this chart if in PULSE_COUNT fitness func, and fitness otherwise
        # Value is always an array separated by semicolons. If values in __data, then use those. Otherwise, use scalar pulses or fitness
        if len(self.__data) > 0:
            # Flatten data
            value = [str(item) for sublist in self.__data for item in sublist]
        else:
            if is_pulse_func(self.__config):
                value = [str(self.__pulses)]
            else:
                value = [str(self.__fitness)]

        lines[index] = "{},{},{}\n".format(
            self.__index, 
            ';'.join(value),
            self.get_file_attribute('src_population')
        )

        # Write these new liens to the file
        with open("workspace/alllivedata.log", "w+") as allLive:
            allLive.writelines(lines)

    # SECTION Genetic Algorithm related functions
    
    def mutate(self):
        """
        Decide which mutation function to used based on configuration
        Only the full simulation mode uses a special function, otherwise we use the default to operate on the hardware files
        """
        if self.__config.get_simulation_mode() == "FULLY_SIM":
            self.__mutate_simulation(False)
        else:
            self.__mutate_actual(False)
    
    def __mutate_simulation(self, all_random):
        """
        Mutate the simulation mode circuit
        self.__config.get_mutation_probability()
        """
        # Try to mutate each bit, flip if possible
        for i in range(0, len(self.__simulation_bitstream)):
            if all_random:
                self.__simulation_bitstream[i] = self.__rand.integers(0, 2)
            else:
                if self.__config.get_mutation_probability() >= self.__rand.uniform(0,1):
                    # Mutate this bit
                    self.__simulation_bitstream[i] = 1 - self.__simulation_bitstream[i]

    def __mutate_actual(self, all_random):
        """
        Mutate this circuit.
        Can either completely randomize all modifiable bits, or evalute mutation 
        chance per-bit and flip bits if mutation succeeds.

        Parameters
        ----------
        all_random : bool
            If true, will set all modifiable bits to random values, completely randomizing the circuit
            If false, will flip modifiable bits based on the mutation probability
        """

        def mutate_bit(bit, row, col, *rest):
            if self.__config.get_mutation_probability() >= self.__rand.uniform(0,1):
                # Set this bit to either a 0 or 1 randomly
                # Keep in mind that these are BYTES that we are modifying, not characters
                # Therefore, we have to set it to either ASCII 0 (48) or ASCII 1 (49), not actual 0 or 1, which represent different characters
                # and will corrupt the file if we mutate in this way
                # 48 = 0, 49 = 1. To flip, just need to do (48+49) - the current value (48+49=97)
                # This now always flips the bit instead of randomly assigning it every time
                # Note: If prev != 48 or 49, then we changed the wrong value because it was not a 0 or 1 previously
                self.__log_event(4, "Mutating:", self, "@(", row, ",", col, ") previous was", bit)
                return 97 - bit
        
        def randomize_bit(*rest):
            return self.__rand.integers(48, 50)

        if all_random:
            self.__run_at_each_modifiable(randomize_bit)
        else:
            self.__run_at_each_modifiable(mutate_bit)

    def __run_at_each_modifiable(self, lambda_func, hardware_file = None, accessible_columns = None,
        routing_type=None):
        """
        Runs the lambda_func at every modifiable position
        Args passed to lambda_func: value of bit (as a byte), row, col
        If lambda_func returns a value (byte), then the bit is set to that number
        If lambda_func returns None, then the bit is left unmodified
        Keep in mind the bytes are the ASCII codes, so for example 49 = 1

        .. todo::
            Go over this with someone who can clarify what all of the data types are. 

        Parameters
        ----------
        lambda_func : Callable
            This function is called for each modifiable bit. The bit value is passed into lambda_func.
            If lambda_func returns None, the bit is left unmodified. If lambda_func returns another value,
            then the bit at that position is replaced with the return value of lambda_func.
        hardware_file : str | None
            The path to the hardware file to read from/write to. If no value provided, uses this Circuit's hardware file.
        accessible_columns : list[str] | None
            The accessible columns. If no value provided, uses the current configuration value.
        routing_type: str | None
            The routing type (MOORE or NEWSE). If no value provided, uses the current configuration value.
        """

        if hardware_file is None:
            hardware_file = self.__hardware_file

        if accessible_columns is None:
            accessible_columns = self.__config.get_accessed_columns()

        if routing_type is None:
            routing_type = self.__config.get_routing_type()

        # Set tile to the first location of the substring ".logic_tile"
        # The b prefix makes the string an instance of the "bytes" type
        # The .logic_tile header indicates that there is a tile, so the "tile" variable stores the starting point of the current tile
        tile = hardware_file.find(b".logic_tile")
        
        while tile > 0:
            # Set pos to the position of this tile, but with the length of ".logic_tile" added so it is in front of where we have the x/y coords
            pos = tile + len(".logic_tile")
            
            # Check if the position is legal to modify
            if self.__tile_is_included(hardware_file, pos):
                # Find the start and end of the line; the positions of the \n newline just before and at the end of this line
                # The start is the newline position + 1, so the first valid bit character
                # line_size is self-explanatory
                # This finds the length of a standard line of bits (so the width of each data-containing line in this tile)
                line_start = hardware_file.find(b"\n", tile) + 1
                line_end = hardware_file.find(b"\n", line_start + 1)
                line_size = line_end - line_start + 1

                # Determine which rows we can modify
                # TODO ALIFE2021 The routing protocol here is dated and needs to mimic that of the Tone Discriminator
                if routing_type == "MOORE":
                    rows = [1, 2, 13]
                elif routing_type == "NEWSE":
                    rows = [1, 2]
                # Iterate over each row and the columns that we can access within each row
                for row in rows:
                    for col in accessible_columns:
                        # This will get us to individual bits. If the mutation probability passes
                        # Our position is now going to be the start of the first line, plus the line size multiplied to get to our desired row,
                        # and finally added to the column (with the int cast to sanitize user input)
                        pos = line_start + line_size * (row - 1) + int(col)
                        bit_value = hardware_file[pos]
                        lambda_return = lambda_func(bit_value, row, col)
                        if lambda_return is not None:
                            # need to re-assign the bit
                            hardware_file[pos] = lambda_return

            # Find the next logic tile, and start again
            # Will return -1 if .logic_tile isn't found, and the while loop will exit
            tile = hardware_file.find(b".logic_tile", tile + 1)

    def get_file_intrinsic_modifiable_bitstream(self, hardware_file):
        """
        Returns an array of bytes (that correspond to characters, so they will either be 48 or 49)
        These bytes represent the bits of the circuit's bitstream that can be modified. All other bits are left out.
        This is the general form of get_intrensic_modifiable_bitstream(self)

        Parameters
        ----------
        hardware file : str
            The hardware file of the circuit you want the bitstream of.

        Returns
        -------
        list[int]
            Returns the bits of the modifiable bitstream in the project.
        """
        bitstream = []
        def handle_bit(bit, *rest):
            bitstream.append(bit)
            return None
        
        self.__run_at_each_modifiable(handle_bit, hardware_file)

        return bitstream

    def get_intrinsic_modifiable_bitstream(self):
        """
        Returns an array of bytes (that correspond to characters, so they will either be 48 or 49)
        These bytes represent the bits of the circuit's bitstream that can be modified. All other bits are left out

        Returns
        -------
        list[int]
            List of all modifyable bits in bitstream.
        """
        return self.get_file_intrinsic_modifiable_bitstream(self.__hardware_file)
    
    def reconstruct_from_bistream(self, bitstream, accessible_columns, routing_type):
        """
        Takes this circuit, and replaces all of its modifiable bits with those in
        the provided bitstream

        .. todo::
            Someone should review this after looking at __run_at_each_modifiable()

        Parameters
        ----------
        bitstream : list[int]
            The bitstream we want to merge with the file ?????
        accessible_columns : ??
            ???
        routing_type : ??
            ??
        """
        i = 0
        def handle_bit(*rest):
            nonlocal i
            new_bit = bitstream[i]
            i += 1
            return new_bit
        self.__run_at_each_modifiable(handle_bit, accessible_columns=accessible_columns, routing_type=routing_type)

    def copy_genes_from(self, parent, crossover_point):
        """
        Decide which crossover function to used based on configuration
        Only the full simulation mode uses a special crossover function, otherwise we use the default to operate on the hardware files
        Note: Chooses between simulated and actual based on if config says it's in 'FULLY_SIM'
        We are not sure whether parent puts information before or after the crossover point, but we believe it puts the parent's information first.

        Parameters
        ----------
        parent : Circuit
            The other circuit the crossover is being performed with
        corssover_point : int
            The point in the modifiable bitstream to perform the point crossover.
        """
        if self.__config.get_simulation_mode() == "FULLY_SIM":
            self.__crossover_sim(parent, crossover_point)
        else:
            self.__crossover_actual(parent, crossover_point)
        
    def __crossover_sim(self, parent, crossover_point):
        """
        Simulated crossover, pulls first n bits from parent and remaining from self
        
        Parameters
        ----------
        parent : Circuit
            The other circuit the crossover is performed with
        crossover_point : int
            The index in the editable bitstream the crossover occours at
        """
        for i in range(0, crossover_point):
            self.__simulation_bitstream[i] = parent.__simulation_bitstream[i]
        # Remaining bits left unchanged
        
    def __crossover_actual(self, parent, crossover_point):
        """
        Copy part of the hardware file from parent into this circuit's hardware file.
        Additionally, need to copy the parent's info line

        Parameters
        ----------
        parent : Circuit
            The circuit file this circuit is being crossed with
        crossover_point : int
            The index in the editable bitstream this crossover is occouring at
        """
        parent_hw_file = parent.get_hardware_file()
        # Need to keep track separately since we can have different-length comments
        parent_tile = parent_hw_file.find(b".logic_tile")
        my_tile = self.__hardware_file.find(b".logic_tile")
        while my_tile > 0:
            my_pos = my_tile + len(".logic_tile")
            parent_pos = parent_tile + len(".logic_tile")
            if self.__tile_is_included(self.__hardware_file, my_pos):
                line_start = parent_hw_file.find(b"\n", parent_tile) + 1
                line_end = parent_hw_file.find(b"\n", line_start + 1)
                line_size = line_end - line_start + 1

                my_pos = my_tile + line_size * (crossover_point - 1)
                parent_pos = parent_tile + line_size * (crossover_point - 1)

                data = parent_hw_file[parent_pos:parent_pos + line_size]
                self.update_hardware_file(my_pos, line_size, data)

            parent_tile = parent_hw_file.find(b".logic_tile", parent_tile + 1)
            my_tile = self.__hardware_file.find(b".logic_tile", my_tile + 1)
        
        # Need to set our source population to our parent's
        src_pop = parent.get_file_attribute("src_population")
        if src_pop != None:
            self.set_file_attribute("src_population", src_pop)

    def copy_sim(self, src):
        """
        Copies src's simulation bitstream into itself.

        Parameters
        ----------
        src : Circuit
            Source circuit to be copied
        attribute : str
            Attribute in the mmaped file you want information about?

        Returns
        -------
        str
            file attributes?
        """
        self.__simulation_bitstream = []
        for val in src.get_sim_bitstream():
            self.__simulation_bitstream.append(val)

    # SECTION Functions involving the underlying hardware

    # TODO Add error checking here
    def update_hardware_file(self, pos, length, data):
        """
        Make changes to the hardware file associated with this circuit, updating it
        with the value in "data"

        .. todo::
            Pre-existing TODO: Add error checking here
        
        
        Parameters
        ----------
        pos : int
            The position in the hardware file to write data at
        length : int
            The length of the data to write
        data : ReadableBuffer
            The data to write into the hardware file
        """
        self.__hardware_file[pos:pos + length] = data

    def write_hardware_changes(self):
        """
        Write the changes that were made to the mmap instance back to
        its underlying file.
        """
        self.__hardware_file.flush()

    def replace_hardware_file(self, new_file_path):
        """
        Replaces the hardware file associated with this Circuit with
        the given file.

        Parameters
        ----------
        new_file_path : str
            The file path to move this hardware's file to
        """
        self.__hardware_file.close()
        hardware_filepath = self.get_hardware_filepath()
        copyfile(new_file_path, hardware_filepath)
        hardware_file = open(hardware_filepath, "r+")
        self.__hardware_file = mmap(hardware_file.fileno(), 0)
        hardware_file.close()

    def copy_hardware_from(self, source):
        """
        Copy the hardware from a source circuit to this circuit.
        
        Parameters
        ----------
        source : Circuit
            Source circuit to copy information from
        """
        source.write_hardware_changes()
        self.replace_hardware_file(source.get_hardware_filepath())

    # SECTION Getters.
    def get_fitness(self):
        """
        Returns the fitness of this circuit.

        Returns
        -------
        float | int
            the fitness of this circuit
        """
        return self.__fitness

    def get_pulses(self):
        """
        Returns the last pulse count recorded by the circuit

        Returns
        -------
        int
            The nummber of pulses recorded
        """
        return self.__pulses

    def get_mean_frequency(self):
        """
        Returns the mean frequency read by the circuit (for pulse consistency only)

        Returns
        -------
        float
            mean frequency of the circuit
        """
        return self.__mean_freq

    def get_mean_voltage(self):
        """
        Returns the last mean voltage recorded by the circuit

        Returns
        -------
        float
            The mean voltage of the circuit
        """
        return self.__mean_voltage

    def get_hardware_file(self):
        """
        Returns the hardware file of this circuit
        
        Returns
        -------
        mmap
            Memory Mapped hardware file of this circuit
        """
        return self.__hardware_file

    # NOTE may need to add the file extension here (.asc)
    def get_hardware_filepath(self):
        """
        Returns the path to the hardware file associated with this
        Circuit (the raw .asc)

        Returns
        -------
        Path
            The file path to the .asc file of this circuit
        """
        return self.__hardware_filepath

    # NOTE may need to add the file extension here (.bin)
    def get_bitstream_filepath(self):
        """
        Returns the path to the bitstream file associated with this
        Circuit (the compiled .bin)

        Returns
        -------
        Path
            The file path to the compiled circuit .bin
        """
        return self.__bitstream_filepath

    def get_data_filepath(self):
        """
        Returns the path to the data log file associated with this
        Circuit.

        Returns
        -------
        Path
            Path to the log file for data for this circuit
        """
        return self.__data_filepath

    def get_index(self):
        """
        Returns the index of this Circuit, as provided upon initialization.

        Returns
        -------
        int
            index of circuit provided upon initialization
        """
        return self.__index

    # SECTION Miscellanious helper functions.
    def __tile_is_included(self, hardware_file, pos):
        """
        Determines whether a given tile is available for modificiation.
        NOTE: Tile = the .logic_tile in the asc file.

        .. todo::
            Preexisting todo: Replace magic values with a more generalized solution. 
            These magic values are indicative of the underlying hardware (ice40kh1k)

        Parameters
        ----------
        hardware_file : mmap
            Memory Mapped hardware file
        pos : int
            Index of the first byte in the .asc file for the hardware

        Returns
        -------
        bool
            True if the tile at that position is valid (The Tiles we can modigy)
        """
        # Replace these magic values with a more generalized solution
        # Magic values are indicative of the underlying hardware (ice40hx1k)
        # A different model will require different magic values (i.e. ice40hx8k)
        VALID_TILE_X = range(4, 10)
        VALID_TILE_Y = range(1, 17)

        # NOTE x and y are stored as ints to aid the loops that search and identify
        # tiles while scraping the asc files
        # This is in the actual asc file; this is why we can simply pull from "pos"
        # i.e. you'll see the header ".logic_file 1 1" - x=1, y=1
        
        # This is where we had a fundamental issue before: The value in the hardware at this position is going to be an ASCII char value, not the actual
        # number. Here, we parse the byte as an integer, then to a char, then back to an integer
        
        # However, we have a great problem now: what about multi-digit numbers?
        # Find the space that separates the x and y, and find the end of the line
        # Then, grab the bytes for x, grab the bytes for y, convert to strings, and parse those strings
        space_pos = hardware_file.find(b" ", pos + 1)
        eol_pos = hardware_file.find(b"\n", pos)
        x_bytes = hardware_file[pos:space_pos]
        y_bytes = hardware_file[space_pos:eol_pos]
        x_str = x_bytes.decode("utf-8").strip()
        y_str = y_bytes.decode("utf-8").strip()
        x = int(x_str)
        y = int(y_str)
        is_x_valid = x in VALID_TILE_X
        is_y_valid = y in VALID_TILE_Y

        return is_x_valid and is_y_valid

    # Values for MAP elites
    def get_low_value(self):
        """
        Returns
        -------
        int
            Low Value for MAP elites
        """
        return self.__low_val
    def get_high_value(self):
        """
        Returns
        -------
        int
            High Value for MAP elites
        """
        return self.__high_val

    def __log_event(self, level, *event):
        """
        Emit an event-level log. This function is fulfilled through
        the logger.
        """
        self.__logger.log_event(level, *event)

    def __log_info(self, level, *info):
        """
        Emit an info-level log. This function is fulfilled through
        the logger.
        """
        self.__logger.log_info(level, *info)

    def __log_error(self, level, *error):
        """
        Emit an error-level log. This function is fulfilled through
        the logger.
        """
        self.__logger.log_error(level, *error)

    def __log_warning(self, level, *warning):
        """
        Emit a warning-level log. This function is fulfilled through
        the logger.
        """
        self.__logger.log_warning(level, *warning)
